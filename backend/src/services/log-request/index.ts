import { Raw } from "typeorm"
import { TraceParams } from "@common/types"
import { ApiEndpoint, ApiTrace } from "models"
import { AppDataSource } from "data-source"
import Error500InternalServer from "errors/error-500-internal-server"
import { DatabaseService } from "services/database"
import { BlockFieldsService } from "services/block-fields"
import { AuthenticationConfigService } from "services/authentication-config"
import { skipAutoGeneratedMatch } from "utils"
import { RedisClient } from "utils/redis"
import { TRACES_TO_ANALYZE_KEY } from "~/constants"

export class LogRequestService {
  static async logRequest(traceParams: TraceParams): Promise<void> {
    const queryRunner = AppDataSource.createQueryRunner()
    await queryRunner.connect()
    try {
      /** Log Request in ApiTrace table **/
      const path = traceParams?.request?.url?.path
      const method = traceParams?.request?.method
      const host = traceParams?.request?.url?.host
      const requestParameters = traceParams?.request?.url?.parameters
      const requestHeaders = traceParams?.request?.headers
      const requestBody = traceParams?.request?.body
      const responseHeaders = traceParams?.response?.headers
      const responseBody = traceParams?.response?.body
      const apiTraceObj = new ApiTrace()
      apiTraceObj.path = path
      apiTraceObj.method = method
      apiTraceObj.host = host
      apiTraceObj.requestParameters = requestParameters
      apiTraceObj.requestHeaders = requestHeaders
      apiTraceObj.requestBody = requestBody
      apiTraceObj.responseStatus = traceParams?.response?.status
      apiTraceObj.responseHeaders = responseHeaders
      apiTraceObj.responseBody = responseBody
      apiTraceObj.meta = traceParams?.meta

      await BlockFieldsService.redactBlockedFields(apiTraceObj)
      await AuthenticationConfigService.setSessionMetadata(apiTraceObj)

      const apiEndpoint = await queryRunner.manager.findOne(ApiEndpoint, {
        where: {
          pathRegex: Raw(alias => `:path ~ ${alias}`, { path }),
          method,
          host,
        },
        relations: { openapiSpec: true },
        order: {
          numberParams: "ASC",
        },
      })
      if (
        apiEndpoint &&
        !skipAutoGeneratedMatch(apiEndpoint, apiTraceObj.path)
      ) {
        const currDate = new Date()
        apiTraceObj.createdAt = currDate
        apiEndpoint.updateDates(currDate)
        apiTraceObj.apiEndpointUuid = apiEndpoint.uuid
        await queryRunner.manager
          .createQueryBuilder()
          .update(ApiEndpoint)
          .set({
            firstDetected: apiEndpoint.firstDetected,
            lastActive: apiEndpoint.lastActive,
          })
          .where("uuid = :id", { id: apiEndpoint.uuid })
          .execute()
      }
      await queryRunner.manager.insert(ApiTrace, apiTraceObj)
      if (apiTraceObj.apiEndpointUuid) {
        RedisClient.pushValueToRedisList(
          TRACES_TO_ANALYZE_KEY,
          [apiTraceObj.uuid],
          true,
        )
      }
    } catch (err) {
      console.error(`Error in Log Request service: ${err}`)
      throw new Error500InternalServer(err)
    } finally {
      await queryRunner.release()
    }
  }

  static async logRequestBatch(traceParamsBatch: TraceParams[]): Promise<void> {
    for (let i = 0; i < traceParamsBatch.length; i++) {
      await this.logRequest(traceParamsBatch[i])
    }
  }
}
